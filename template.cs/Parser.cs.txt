@using Extensions
@using Parser
@using System.Text.RegularExpressions
@using Yanp.Data
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace @Model.GetDefine("YYNAMESPACE", "Parser");
@Include("Utility.cs")
public partial class Parser
{
    public List<IToken<@Model.Syntax.Default>> TokenStack { get; } = new();
    public static int[,] Tables { get; } = new [,]
        {
@{
var reduce_to_index = Model.GetGrammarLines()
    .Select((x, i) => (x, i))
    .ToDictionary(x => x.x, x => -x.i - 1);

var symbol_to_index = Model.GetSymbols()
    .Select((x, i) => (x, i))
    .ToDictionary(x => x.x.get_Value(), x => x.i);

foreach (var table in Model.Tables)
{
    var line = new int[symbol_to_index.Count];
    table.get_Actions().Where(x => x.Value is ShiftAction).Each(x => line[symbol_to_index[x.Key.get_Value()]] = Model.NodeToTable(x.Value.Cast<ShiftAction>().get_Next()).get_Index());
    table.get_Actions().Where(x => x.Value is ReduceAction).Each(x => line[symbol_to_index[x.Key.get_Value()]] = reduce_to_index[x.Value.Cast<ReduceAction>().get_Reduce()]);
            @:{@string.Join(", ", line)},
}
}
        };

    public @Model.Syntax.Default Parse(ILexer<@Model.Syntax.Default> lex)
    {
        var current = 0;

        while (true)
        {
            var token = lex.PeekToken();
            var x = Tables[current, token.InputToken];

            if (x < 0)
            {
                token = RunAction(x);
                if (token.InputToken == (int)Symbols._ACCEPT) return token.Value;
                current = TokenStack.Count == 0 ? 0 : TokenStack[^1].TableIndex;
                x = Tables[current, token.InputToken];

                token.TableIndex = x;
                TokenStack.Add(token);
                current = x;
            }
            else if (x == 0)
            {
                OnError(lex);
            }
            else
            {
                _ = lex.ReadToken();
                token.TableIndex = x;
                TokenStack.Add(token);
                current = x;
            }
        }
    }

    public ReduceToken<@Model.Syntax.Default> RunAction(int yy_no)
    {
        switch (yy_no)
        {
@{
foreach (var reduce in reduce_to_index)
{
    var length = reduce.Key.get_Grammars().Count();
    var action = reduce.Key.get_Action()?.get_Value();
    var actformat = action is { } a ?
        Regex.Replace(a, @"\$(\$|\d+)", m =>
        {
            if (m.Groups[1].Value == "$") return "var yy_value";

            var n = Int32.Parse(m.Groups[1].Value) - 1;
            var g = reduce.Key.get_Grammars()[n];
            var d = Model.Syntax.Declares[g.get_Value()];

            if (d.get_Type() != "") return $"(({d.get_Type()})GetValue({n - length}))";
            return $"GetValue({n - length})";
        })
        : $"var yy_value = GetValue({length});";
    var sym = ((Func<Token, string>)Model.KeyValues["csterms"])(reduce.Key.get_Name());

            @:case @reduce.Value:
                @:{
                    @:TraceAction("@reduce.Key");
                    @:@actformat
                    @:return DoAction(Symbols.@sym, yy_value, @length);
                @:}
@:
}
}
            default:
                throw new InvalidProgramException();
        }
    }

    public IToken<@Model.Syntax.Default> GetToken(int from_last_index) => TokenStack[TokenStack.Count - from_last_index];

    public @Model.Syntax.Default GetValue(int from_last_index) => GetToken(from_last_index).Value;

    public bool IsAccept(IToken<@Model.Syntax.Default> token) => Tables[TokenStack.Count == 0 ? 0 : TokenStack[^1].TableIndex, token.InputToken] != 0;

    public ReduceToken<@Model.Syntax.Default> DoAction(Symbols type, @Model.Syntax.Default value, int length)
    {
        TokenStack.RemoveRange(TokenStack.Count - length, length);
        return new() { InputToken = (int)type, Value = value };
    }

    public void OnError(ILexer<@Model.Syntax.Default> lex)
    {
        Debug.Fail("syntax error");
        SyntaxError(lex.PeekToken());
    }

    [Conditional("TRACE")]
    public void TraceAction(string s) => Debug.WriteLine(s);
}
