@using Extensions
@using Parser
@using System.Text.RegularExpressions
@using Yanp.Data
namespace @Model.GetDefine("YYNAMESPACE", "Parser");
@Include("Utility.cs")
public partial class Parser<T>
{
    public List<IToken<T>> TokenStack { get; } = new();
    public static int[,] Tables { get; } = new [,]
        {
@{
var reduce_to_index = Model.GetGrammarLines()
    .Select((x, i) => (x, i))
    .ToDictionary(x => x.x, x => -x.i - 1);

var symbol_to_index = Model.GetSymbols()
    .Select((x, i) => (x, i))
    .ToDictionary(x => x.x.get_Value(), x => x.i);

foreach (var table in Model.Tables)
{
    var line = new int[symbol_to_index.Count];
    table.get_Actions().Where(x => x.Value is ShiftAction).Each(x => line[symbol_to_index[x.Key.get_Value()]] = Model.NodeToTable(x.Value.Cast<ShiftAction>().get_Next()).get_Index());
    table.get_Actions().Where(x => x.Value is ReduceAction).Each(x => line[symbol_to_index[x.Key.get_Value()]] = reduce_to_index[x.Value.Cast<ReduceAction>().get_Reduce()]);
            @:{@string.Join(", ", line)},
}
}
        };

    public T Parse(ILexer<T> lex)
    {
        var current = 0;

        while (true)
        {
            var token = lex.PeekToken();
            var x = Tables[current, token.InputToken];

            if (x < 0)
            {
                token = RunAction(x);
                if (token.IsAccept) return token.Value;
                current = TokenStack.Count == 0 ? 0 : TokenStack[^1].TableIndex;
                x = Tables[current, token.InputToken];

                token.TableIndex = x;
                TokenStack.Add(token);
                current = x;
            }
            else if (x == 0)
            {
                OnError(lex);
            }
            else
            {
                _ = lex.ReadToken();
                token.TableIndex = x;
                TokenStack.Add(token);
                current = x;
            }
        }
    }

    public IToken<T> RunAction(int yy_no)
    {
        switch (yy_no)
        {
@{
foreach (var reduce in reduce_to_index)
{
    var length = reduce.Key.get_Grammars().Count();
    var action = reduce.Key.get_Action()?.get_Value();
    var actformat = action is { } a ?
        a
        /*
        Regex.Replace(a, @"\$(\$|\d+)", m =>
        {
            if (m.Groups[1] == "$") return "var yy_value";
            return "var yy_value2";
        })
        */
        : $"var yy_value = GetValue({length});";
    var sym = ((Func<Token, string>)Model.KeyValues["csterms"])(reduce.Key.get_Name());

            @:case @reduce.Value:
                @:TraceAction("@reduce.Key");
                @:@actformat
                @:return DoAction(Symbols.@sym, @length, yy_value);
@:
}
}
            default:
                throw new InvalidProgramException();
        }
    }

    public IToken<T> GetToken(int from_last_index) => TokenStack[TokenStack.Count - from_last_index];

    public T GetValue(int from_last_index) => GetToken(from_last_index).Value;

    public bool IsAccept(IToken<T> token) => Tables[TokenStack.Count == 0 ? 0 : TokenStack[^1].TableIndex, token.InputToken] != 0;

    public IToken<T> DoAction(Symbols type, int length, T value) => DoAction(new Token { Type = type, Value = value }, length);

    public IToken<T> DoAction(IToken<T> token, int length)
    {
        TokenStack.RemoveRange(TokenStack.Count - length, length);
        return token;
    }

    public void OnError(ILexer<T> lex)
    {
        Debug.Fail("syntax error");
        SyntaxError(lex.PeekToken());
    }

    [Conditional("TRACE")]
    public void TraceAction(string s) => Debug.WriteLine(s);
}
