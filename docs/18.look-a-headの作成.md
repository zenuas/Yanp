## look-a-headの作成

還元のタイミングで先読みを行いシフトか還元かを求める必要がある。
これは還元が行末か否かで求め方が異なる。

### 行の途中の還元の場合

次のような構文規則で規則のない `void : .` は単独では存在しえず、必ず `stmt : . void ';'` のような状態とセットになる。
この場合、先読み記号 `';'` の場合のみ `void : .` を還元してよい。
[head集合](16.head集合の作成.md)を元に先読み記号を求める。
続く規則が[nullable集合](15.nullable集合の作成.md)の場合は次の規則を参照する。

```
stmt : call ';'
     | void ';'
call : VAR '(' args ')'
args : void
     | argn
argn : VAR
     | argn ',' VAR
void :
```

また、`call: VAR '(' . args ')'` の場合であっても先読み記号が `')'` の場合のみ `void` の還元、`args` の還元が起こってよい。


### 行末の還元の場合

次のような構文規則で行末にある `void : .` は、`call : VAR . args` のような状態とセットになる事がある。
続く規則がないため[follow集合](17.follow集合の作成.md)を利用する。
`call` のfollow集合は `';'` と `EOL` であるため、いずれかで還元する。

```
stmt : VAR '=' call ';'
     | call EOL
call : VAR args
args : void
     | argn
argn : VAR
     | argn ',' VAR
void :
```

この時 `VAR '=' VAR EOL` という誤った入力を与えると `call : VAR . args` が還元してしまう。
これは構文規則のみを見るだけでは正しい先読み記号が分からないためである。

### 余談: GNU/bisonの場合

次のような構文規則で `call: VAR '(' . args ')'` の時に `';'` という誤った先読み記号を読み取るとエラーになるが、
GNU/bisonで作成した構文解析器で実行すると、`$default reduce using rule 8 (void)` とある通りエラーになる前に `void`、`args` が還元してしまう。
これは `void` が文脈に関係なく還元するためである。
全体としてエラーにはなるので問題になる事はないが、余計な還元をしてしまう事態が起こる。

```
stmt : call ';'
     | void ';'
call : VAR '(' args ')'
args : void
     | argn
argn : VAR
     | argn ',' VAR
void :

---

state 5

    3 call: VAR '(' . args ')'

    VAR  shift, and go to state 9

    $default  reduce using rule 8 (void)

    args  go to state 10
    argn  go to state 11
    void  go to state 12
```
